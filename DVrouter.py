####################################################
# DVrouter.py
# Name:
# HUID:
#####################################################

import base64
import math
import pickle
from typing import Any, Optional
from packet import Packet
from router import Router


type _Addr = Any
type _Port = Any
type _Cost = int

# Heuristic
_INFINITY = math.inf


class _ForwardingTableEntry:
    def __init__(self, cost: _Cost, next_hop: Optional[_Addr] = None, port: Optional[_Port] = None):
        self.cost = cost
        self.maybe_next_hop = next_hop
        self.maybe_port = port

class _NeighborEntry:
    def __init__(self, cost: _Cost, port: _Port):
        self.cost = cost
        self.port = port

class _DistanceVectorEntry:
    def __init__(self, cost: _Cost, next_hop: _Addr):
        self.cost = cost
        self.next_hop = next_hop


def _serialize(obj: Any) -> str:
    bytes_ = pickle.dumps(obj)
    str_ = base64.b64encode(bytes_).decode()
    return str_

def _deserialize(str_: str) -> Any:
    bytes_ = base64.b64decode(str_.encode())
    obj = pickle.loads(bytes_)
    return obj


# Who even names a class like this?
# Variables should have no underscore prefix
# (assuming this class is not used by any external authorities)
class DVrouter(Router):
    """Distance vector routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0

        # TODO
        #   add your own class fields and initialization code here
        self.__forwarding_table: dict[_Addr, _ForwardingTableEntry] = {}
        self.__forwarding_table[self.addr] = _ForwardingTableEntry(cost=0, next_hop=self.addr, port=None)

        self.__neighbor_addrs_by_ports: dict[_Port, _Addr] = {}
        self.__neighbors_by_addrs: dict[_Addr, _NeighborEntry] = {}

    def handle_packet(self, _port: _Port, packet: Packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if packet.dst_addr in self.__forwarding_table:
                dst = self.__forwarding_table[packet.dst_addr]
                if dst.cost < _INFINITY and dst.maybe_port is not None:
                    self.send(dst.maybe_port, packet)
        else:
            # Hint: this is a routing packet generated by your routing protocol           
            # If the received distance vector is different
            #   update the local copy of the distance vector
            #   update the distance vector of this router
            #   update the forwarding table
            #   broadcast the distance vector of this router to neighbors
            distance_vector: dict[_Addr, _DistanceVectorEntry] = _deserialize(packet.content)
            is_received_distance_vector_different = False
            neighbor_addr = packet.src_addr

            for addr, dst in distance_vector.items():
                if dst.cost == _INFINITY:
                    if addr in self.__forwarding_table and self.__forwarding_table[addr].maybe_next_hop == neighbor_addr:
                        self.__forwarding_table[addr] = _ForwardingTableEntry(cost=_INFINITY, next_hop=None, port=None)
                        is_received_distance_vector_different = True

                else:
                    neighbor_cost = self.__neighbors_by_addrs[neighbor_addr].cost
                    new_neighbor_cost = min(dst.cost + neighbor_cost, _INFINITY)

                    if addr not in self.__forwarding_table or new_neighbor_cost < self.__forwarding_table[addr].cost:
                        neighbor_port = self.__neighbors_by_addrs[neighbor_addr].port
                        self.__forwarding_table[addr] = _ForwardingTableEntry(cost=new_neighbor_cost, next_hop=neighbor_addr, port=neighbor_port)
                        is_received_distance_vector_different = True

            if is_received_distance_vector_different:
                self.__broadcast_to_neighbors()

    def handle_new_link(self, port: _Port, endpoint: _Addr, cost: _Cost):
        """Handle new link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors

        self.__neighbor_addrs_by_ports[port] = endpoint
        self.__neighbors_by_addrs[endpoint] = _NeighborEntry(cost=cost, port=port)

        maybe_dst = self.__forwarding_table.get(endpoint)
        if maybe_dst is None or maybe_dst.cost != cost:
            self.__forwarding_table[endpoint] = _ForwardingTableEntry(cost=cost, next_hop=endpoint, port=port)
            self.__broadcast_to_neighbors()

    def handle_remove_link(self, port: _Port):
        """Handle removed link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        
        neighbor_addr = self.__neighbor_addrs_by_ports.pop(port)
        del self.__neighbors_by_addrs[neighbor_addr]
        
        for addr, dst in self.__forwarding_table.items():
            if dst.maybe_port == port:
                self.__forwarding_table[addr] = _ForwardingTableEntry(cost=_INFINITY, next_hop=None, port=None)

        self.__broadcast_to_neighbors()

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the distance vector of this router to neighbors
            self.__broadcast_to_neighbors()

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"DVrouter(addr={self.addr})"

    def __broadcast_to_neighbors(self):
        for neighbor_addr, neighbor in self.__neighbors_by_addrs.items():
            distance_vector = {addr: _DistanceVectorEntry(cost=_INFINITY if neighbor_addr != addr and neighbor_addr == entry.maybe_next_hop else entry.cost, next_hop=entry.maybe_next_hop) for addr, entry in self.__forwarding_table.items()} # Poisoned reverse
            content = _serialize(distance_vector)

            port = neighbor.port
            packet = Packet(kind=Packet.ROUTING, src_addr=self.addr, dst_addr=neighbor_addr, content=content)
            self.send(port, packet)
